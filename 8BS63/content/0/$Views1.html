<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Programming Viewstore. Part 1</title>
  <style type="text/css">
    body {
	    background-color: black;
	    text-align: center;
    }
    
    table {
	    color: white;
	    font: 15px "Courier New", "Courier", monospace;
	    text-align: left;
	    border: 0px;
	    border-collapse: collapse;
	    margin-left: auto;
	    margin-right: auto;
    }
    
    td {
    	margin: 0px;
    	padding: 0px;
    }
  </style>
  </head>
  
  <body>
    <table><tr><td>
PART 1<br /><br />HOW TO WRITE A VIEWSTORE UTILITY<br />by Mark Colton, author of VIEW, VIEWSHEET AND VIEWSTORE<br /><br />Since the available space for ROM code is limited to 16k, ViewStore has<br />provision for extra programs or utilities that exist outside the ROM to be<br />used.  ViewStore is supplied with several utilities that supplement the ROM,<br />and has an interface built into it to allow utility programs to use routines<br />inside the ROM.  Certain areas of memory are also allocated for use by<br />utility programs.  Given the knowledge of the  interface and memory<br />allocation, it is possible to write extra utilities for ViewStore.  The<br />purpose of this document is to define the utility interface to enable third<br />parties to write their own utilities.  A good knowledge of ViewStore and<br />assembly language will be essential.<br /><br />The Interface<br /><br />Various routines within the ROM are available for use by utilities.  The<br />routines provide the utility with the means to access format files and data<br />records and indexes and assorted useful functions.  The ROM has a jump table<br />at the beginning which directs calls to the various routines in the ROM.<br /><br />As well as access to the ROM routines, the utility has memory allocated to<br />it.  Three areas of memory are available to a utility:<br /><br />        A section of zero page<br />        A section of language absolute workspace<br />        A section of main memory<br /><br />The amount of zero page and language workspace available to a utility depend<br />upon which ROM routines the utility is going to use.  The size and position<br />of the piece of main memory available can only be  determined when the<br />utility is run:  pointers to the start and end of the main workspace are<br />passed when the utility is started.<br /><br />The zero page, language workspace and main memory not available to the<br />utility is used by the ViewStore ROM itself.  A utility should not alter<br />this memory, but the addresses of some locations are defined to allow<br />utilities to read useful parameters.<br /><br />Utility Format<br /><br />The format of a utility must conform to certain rules.  When a utility is<br />located and loaded from the filing system, ViewStore relocates the code to<br />run at a particular point in memory.  This point varies according to the<br />size of the format file loaded and the MOS "high water mark".  On machines<br />with second processors attached, ViewStore relocates the utility to run in<br />the space left above the ROM: from &C000 to &F800.  Using this relocating<br />system, ViewStore make optimum use of the memory available.<br /><br /><br />Since it is not easy to write position independent code for the 6502, the<br />ROM includes a relocating system.  The utility must provide certain<br />information about itself to enable this system to work.  The format of a<br />utility is as follows:- <br />        .start  JMP     code<br />                EQUW    bitmap-start<br />                EQUW    start<br />                EQUS    "version no/copyright string"<br /><br />        .code           /utility code begins here<br /><br />                        /end of utility code<br /><br />        .bitmap         /relocation bitmap<br /><br />                        /end of utility<br /><br />The first word after the initial JMP gives the offset from the beginning of<br />the utility to the relocation bitmap.<br /><br />Since the utility is relocated after being loaded, the actual assembly<br />address is not important, but ViewStore must be told at what address the<br />utility has been assembled, so that it can calculate how much needs to be<br />added or subtracted from the addresses to be relocated.  The second word<br />after the JMP gives the assembly address.  This &2000 for most of the<br />supplied utilities.<br /><br />The version no/copyright string is not essential, but it's a good idea to<br />include one so that you can identify the code.<br /><br />The main hurdle for anyone writing their own utilities will be the<br />generation of the relocation bitmap.  This identifies the addresses that<br />must be relocated.  There is a bit in the bitmap for every byte of code in<br />the utility, excluding the bitmap itself.  A bit set to zero indicates that<br />an address is not to be relocated; a bit set to one indicates that an<br />address is to be relocated.<br /><br />It is only possible to relocate addresses using this system, not single<br />bytes.  This means that it is not possible to set up or move addresses using<br />immediate data:<br /><br />                LDA     #place<br />                STA     var<br />                LDA     #place AND &FF<br />                STA     var+1<br /><br />is not allowed.  You must use the form:<br /><br />                LDA     plcew<br />                STA     var<br />                LDA     placew+1<br />                STA     var+1<br /><br />   .placed      EQUW            place<br /><br />In the bitmap, a bit which is set is taken to refer to a 16 bit address<br />within the program; it is therefore impossible to have two adjacent bits set<br />since the second bit it referring to the high byte of the address.<br /><br />Given eight adjacent bytes, all represented by a single byte in the bitmap,<br />the most significant bit in the bitmap byte corresponds to the first code<br />byte, and the least significant bit to the last code byte.<br /><br />As an example:  the first byte of a relocation bitmap always corresponds to<br />the JMP and EQUW structure at the beginning of the utility.  Assuming that<br />you have a copyright string (which contains no addresses to be relocated),<br />the first byte of the bitmap should always be &44.  The bit string for this<br />is:<br /><br />         MSB         LSB<br /><br />         0 1 0 0 0 1 0 0<br /><br />The first three bits correspond to the three bytes of the JMP instruction.<br />The second two bytes of the JMP instruction contain the address to jump to,<br />which must be relocated.  The first bit of the two bits for this address is<br />therefore set.  The next two bits correspond to the bitmap offset word. This<br />remains constant for any load address, so these two bits are zero.  The next<br />two bits are for the assembly address, which will alter as the utility is<br />relocated, and the first bit is a 1 accordingly.  The last bit is for the<br />first byte of the copyright string; zero since this has no addresses to be<br />relocated.<br /><br />The bitmaps for the utilities which are supplied with ViewStore were<br />generated automatically by an assembler which is not available on the<br />market.  If you are going to write a utility for ViewStore, you must find a<br />way of generating relocation bitmaps.  This could be done in one of three<br />ways:<br /><br />        1.     Generate it by hand<br />        2.     Write a program to take an assembled utility and generate the<br />bitmap<br />        3.     Modify an assembler to generate relocation bitmaps<br />        4.     Assemble it at two different addresses and write a program to<br />compare the two resulting code files.  Those locations which have changed<br />need a set bit in the bitmap.<br /><br />For most people, the last option will be the simplest.<br /><br />The Utility Environment<br /><br />Most utilities will want to operate upon existing databases.  It is<br />possible, though, to have a utility which does not operate on existing data,<br />but creates data, or doesn't act on data at all.<br /><br />An example of this is the SETUP utility, which creates blank databases.  It<br />doesn't refer to any existing data.  Utilities which need to access either<br />format files or data files must first check that a database has been loaded,<br />and abort with an error message if there is no loaded database.<br /><br />This is done by checking the location FILMOD.  If FILMOD is non-zero, then a<br />database is loaded.  If zero, there is no database loaded.<br /><br />The normal sequence of operation will be to load a database in ViewStore,<br />with the LOAD command.  This loads the format file into memory, and locates<br />the data file.  A utility is then started with the UTILITY command.  The<br />utility can read the format file as it requires, and can open and process<br />the information in the data file.  It can use a subset of data identified by<br />the select file.<br /><br />Once the utility is running, it can take control of the machine as it needs<br />to, using the memory available to it, and the ROM routines as required.<br /><br />Naming of Addresses<br /><br />In this document, all location and routine addresses will be referred to by<br />name.  Tables of addresses and values are at the end of the document.<br /><br />You will notice that the names of a block of addresses being with "TEMP".<br />These locations are available for use by the utility as temporary storage,<br />but some are used and altered by routines in the ROM.<br /><br />Temporaries<br /><br />The numbered temporaries are all either a single byte or two bytes long.<br />Those from TEMPFD to TEMP05 are all one byte long; those from TEMP06 to<br />TEMP14 are all two bytes long.  The two byte temporaries are used to store<br />and pass addresses; the single byte temporaries are used to store one byte<br />quantities.<br /><br />Often, values are passed to and from routines using temporaries, as well as<br />registers in the CPU.  Many routines "corrupt" certain temporaries; a list<br />of the temporaries a routine corrupts is given in a summary at the end.<br />Utilities can use temporaries whenever they wish, but of course their use<br />must not clash with any routines that you call in the ROM.<br /><br />Entry Parameters<br /><br />When the utility is started, the following data is provided:<br /><br />   TEMP14           contains the start address of free main memory<br />   VWSLIM           contains  the address of the byte after the last free<br />                    byte in main memory<br /><br />VWSLIM will not change while the utility is running, and the utility must<br />not alter VWSLIM.  TEMP14 may be altered by a ROM call, so it is best to<br />store it somewhere else for later reference.<br /><br />The utility is called with a JSR instruction, and ViewStore expects the<br />utility to hand back control, when it is finished, with an RTS instruction.<br /><br />        .start  TSX<br />                STX          stksav<br />                .<br />                .<br />        .error  LDX          stksav<br />                TXS<br />                RTS<br /><br />Zero Page<br /><br />Zero page is divided up into four areas of different types:<br /><br />   ViewStore variables  read only for utilities. Below &50.<br /><br />   Temporaries          TEMPFD-TEMP<br /> <br />   Floating point       FACCxxand FWRKxx. Start at &6B. read/write for<br />   accumulators         utilities; if the floating point calls are not used<br />                        by the utility. this area can be used as general<br />                        workspace.<br /><br />   General workspace    VWSXTZ-&8F inclusive.<br /><br />Language Workspace<br /><br />   LWORK                                16 byte parameter block used by ROM<br />                                        routines.<br />   FBLOCK                               27 byte filename work area.<br />   LINBUF                               256 byte work area used by one or<br />                                        two ROM routines.<br />   VWSXTL-VWSITL                        area used by ISAM index system. Can<br />                                        be used as general workspace if the<br />                                        utility is not using indexes.<br />   General workspace                    VWSITL-&7FF inclusive.<br /><br /><br />ROM Routines<br /><br />I will describe the ROM routines in the categories that they fall into.  The<br />routine addresses and parameters are summarised in table 1.  All routines<br />should be called with a JSR instruction, except for CALUTI which should be<br />called with a JMP instruction, since returning control to the utility is not<br />usually sensible as the new utility will overwrite the old one in memory.<br /><br /><br />Data File Control<br /><br />These routines give the utility access to the database data file, using the<br />current select file if required.  It is only possible to read sequentially<br />through the data file using these calls, but the data will be returned in<br />sorted order if the selected data was sorted.<br /><br />The utility should not close the intermediate file if it uses it.  This is<br />done automatically when control is returned to the ROM.<br /><br />        INIIMF          Initialise data sequence.  Called to start the data<br />                        reading sequence.<br />        MXTIMF          Get next from data sequence. Each call returns the<br />                        next data record in the sequence.<br /><br /><br />INIIMF<br /><br />This routine is called to initiate a sequence of data transfers.  It opens<br />the main data file, and stores its handle in the location EFILE.  According<br />to the state of the carry flag on entry, it asks the user if he wishes to<br />use a select file.  The user responds with a yes or no, and ViewStore opens<br />the select file (S.database) accordingly.  After this, the select file is<br />transparent to the utility; repeated calls to NXTIMF will either return all<br />the records in the data file if the select file is not being used, or the<br />subset of records in the select file, if specified.<br /><br />On entry:               CC      Don't ask "Use select file (Y,N)?" question.<br />                        CS      Ask select file question.<br /><br />On exit:                VC      No error.<br />                        VS      Error; error code in A.<br /><br />NXTIME<br /><br />After starting the sequence with a call to INIIMF, repeated calls to MXTIMF<br />return the records in the data file one by one.<br /><br />On entry:               A               low byte of address to store record.<br />                        Y               high byte of address to store<br />                                        record.<br />                        TEMP13          address of the byte after the last<br />                                        byte available to store the record.<br /><br />On exit:                VC              No error.<br />                        VS              Error; error code in A.<br /><br />                        CC              Not end of file.<br />                        CS              End of file (returned on the call<br />                                        after the last record has been<br />                                        processed).<br /><br />Errors<br /><br />Many of the ROM routines can return an error status.  An error is usually<br />indicated by either the Carry flag (C), or the Overflow flag (V).  When an<br />error is indicated, the error code is in the A register.  To report the<br />error to the user, call the routine REPERL with this code A.  The various<br />error codes and messages are summarised later.  A utility can use a ROM<br />error message by loading the appropriate code into A, and calling REPERL.<br /><br />All file calls have the same error trapping system: after a call, V is set<br />to indicate an error, clear if there was no error.  This includes errors<br />causing a BRK, that is control is returned to the calling routine even when<br />a BRK is occurred.  When you call REPERL with the returned error code, the<br />BRK message will be reported as normal.<br /><br />REPERL<br /><br />Reports the error message for the error code in A:<br /><br />On entry:         A             contains error code.<br /><br />On exit:          A,X,Y         undefined.<br /><br /><br />Field and Record Control<br /><br />Much of ViewStore's manipulation is on fields and records; accordingly,<br />there are several routines available to make this easier.  There are some<br />routines to locate fields in the header, format file or current record;<br />routines to compare field values; and routines to find the size of a given<br />field.<br /><br />Most of these routines use the two temporaries TEMP06 and TEMP07. TEMP06<br />points to either a field within the format file, or a field within the<br />current record. TEMP07 points to a field within the current record.  The Y<br />indirect indexed addressing mode is used in conjunction with these<br />temporaries to access the field contents: the temporary points to the<br />beginning of the field, and the Y register gives the offset from there.<br /><br />Remember that the format file itself is in the same format as a data file.<br />The same routines are used to process information in records of the database<br />as in the format file itself.  For each field in the database, there is a<br />record in the format file, and this record details the characteristics of<br />its corresponding field in the database.  The header record is the first<br />record in the format file.<br /><br />Data Format<br /><br />The data format is summarised in table 10 at the end of the document.  All<br />fields in ViewStore are stored in ASCII, even numbers and dates; each field<br />ends with an end of field marker; each record ends with an end of record<br />marker; and the file ends with an end of file marker; after the end of file<br />marker, the file is padded up to the physical end of file with null<br />characters.  If you are processing a field's contents, you should test for<br />the end of field using the CHKEOF and CHKEOR routines.  These routines set<br />the flags according to the character that they find.  Don't check for the<br />character value explicitly.<br /><br />Generally, when you make a call to a routine that locates a field, the x<br />register indicates where the field is to be found:<br /><br />        X=0             Field in header; A has field number.<br />        X=1 to 254      Field in format file; X gives format file record<br />                        number; A has field number.  The field numbers of<br />                        the various format file fields are summarised below.<br />        X=225           Field in current record; A has field number; Y has<br />                        record number.<br /><br />Fields within a record are numbered from 1 to 254.  If you ask for a field<br />which is not in the record, the routine will return with the Carry flag set.<br />Whereas ViewStore knows where the format file is located, the address of the<br />current record could be anywhere, and before fields within the current<br />record can be accessed, you must tell ViewStore its address with the SETDPS<br />routine.<br /><br />        GETFLD          General field locate routine; can locate a field in                          the header, format file or current record.<br />        GETFRC          Find the address of a field in the current record.<br />        GETXFL          Return first non-space character of a field in the A<br />                        register, folded to upper case if applicable.<br />        SETDPS          Set the address of the beginning of the current<br />                        record.<br />        CHKEOF          Check the character in the A register for an end of<br />                        field character.<br />        CHKEOR          Check the character in the A register for an end of<br />                        record character.<br />        SIZFLD          Return the size of a given field.<br />        CMPFLD          Compare two fields of the same type and set the<br />                        flags.<br />        SCHFLD          Return the number of a field, given its name.<br />        SCHFLN          Return the next field number, given a name, for an<br />                        ambiguous name specification.<br /><br />        GETWID          Return the display width for a particular field.<br />        GETKYW          Return the key width for a particular field.<br />        CALSBN          Calculate the number of spaces required to be output<br />                        before a numeric field to right justify it within<br />                        the display width.<br /><br />GETFLD<br /><br />This routine locates a field in either the database header, the format file<br />or the current record.  If the field is in the current record, the address<br />of the first character of the field is set into TEMP06 and also into TEMP07.<br />If the field is in the format file, TEMP07 is left unaltered, and the<br />address of the field is put into TEMP06.<br /><br />If X is equal to 255, then the routine uses the value in the Y register to<br />locate a record in a list of current records.  The list of records is<br />numbered from 0 onwards.  The usual way to use this part of the routine will<br />be with Y set to zero, in order to locate a field within a single current<br />record.  If you are using a list of records, then you must not set Y to too<br />high a value, so that the routine runs off the end of the list, unless you<br />have an end of file marker after the last record.<br /><br />Before you use this routine, you must have set the position of the first<br />record in the list by using the SETDPS call.<br /><br />On entry:               A               field number of field to locate;<br />                                        field start at 1.<br />                        X=0             find field in header record.<br />                        X=1 to          find field in format file record; X<br />                        X=254           gives the number of the format file<br />                                        record.<br />                        X=255           find field in list of current<br />                                        records; Y has the number of the<br />                                        record to search, starting at zero.<br />                        Y               only significant if X=255.<br /><br />On exit:                CS              field or record not found; TEMP06<br />                                        (and TEMP07 if X=255) point to the<br />                                        end of record marker if field not<br />                                        found, the end of file marker if<br />                                        record not found.<br />                        CC              field and record found; TEMP06<br />                                        points to the beginning of the<br />                                        field; if the call was made with<br />                                        X=255 then TEMP07 also points to the<br />                                        beginning of the field.<br />                        A,Y             undefined.<br />                        X               preserved.<br /><br /><br />GETFRC<br /><br />This call first sets X to 255, and then calls the GETFLD routine.  The entry<br />and exit conditions are as for GETFLD when X-255, except that X will always<br />return set to 255.<br /><br /><br />GETXFL<br /><br />GETXFL returns the first non-space character in a field, folded to upper<br />case if alphabetic.  It is intended primarily for reading the value of<br />single character fields in the format file, such as the "Field type" field.<br /><br />GETXFL first calls the routine GETFLD.  The entry conditions are the same as<br />GETFLD.  If the call to GETFLD fails, ie the Carry flag is set, then the A<br />register is cleared, and the routine ends.  If the field is  found, then the<br />first character of the field is returned, folded to upper case if<br />alphabetic.  If the field is blank, then the end of field marker will be<br />returned.<br /><br />On entry:               See GETFLD<br /><br />On exit:                        TEMP06 and TEMP07 set as for GETFLD.<br />                        CS      field or record not found, as GETFLD; A set                                  to zero.<br />                        CC      field found; A contains first non-space<br />                                character, folded to upper case if<br />                                alphabetic.<br />                        X,Y     See GETFLD.<br /><br />SETDPS<br /><br />This routine stores the address of the records to be used when using one of<br />the field locate routines with X set to 255.  It should be called whenever<br />the address of one of the records in the list or of one of the fields in the<br />records has altered.  It need not be called if none of the fields has moved,<br />since ViewStore will keep track of its position in the list of records, and<br />move backwards or forwards as necessary to find the field you have asked<br />for.<br /><br />If you are reading records one by one using the NXTIMF call, for example,<br />then you must call SETDPS with their address of the record for each record<br />that you read: the alignment of the fields will alter for each record.<br /><br />On entry:       A               contains low byte of the address of the first<br />                                record in the list.<br />                Y               contains the high byte of the address of the<br />                                first record in the list.<br /><br />On exit:        A,X,Y           undefined.<br /><br /><br />CHKEOF<br /><br />CHKEOF checks the character in the A register for an end of field marker.<br />It should be used rather than checking for the character explicitly since it<br />handles classes of characters rather than single values.  Generally, it is<br />not necessary to detect illegal characters explicitly, it is enough to<br />detect them as an end of field marker.<br /><br />On entry:       A               contains character value to be checked.<br /><br />On exit:        EQ              end of field.<br />                CS              end of record (EQ also set).<br /><br />                VS              illegal character (EQ also set).<br />                A,X,Y           preserved.<br /><br /><br />CHKEOR<br /><br />CHKEOR  checks the character in the A register for an end of record marker.<br /><br />On entry:               A               contains character to be checked.<br /><br />On exit:                EQ              end of record.<br />                        CS              end of file (EQ also set).<br />                        VS              space character (EQ also set).<br />                        A,X,Y           preserved.<br /><br /><br />SIZFLD<br /><br />SIZFLD is provided to allow you to determine the size of a field.  First of<br />all you should locate the field, using one of the field locator routines<br />such GETFLD, which set up TEMP06.  Then call SIZFLD.<br /><br />On entry:               TEMP06          points to the beginning of the<br />                                        field.<br /><br />On exit:                A,Y             have length of field in characters.<br />                        EQ              zero length field.<br />                        X               preserved.<br />                        TEMP06          preserved.<br /><br /><br />CMPFLD<br /><br />CMPFLD compares the values of two fields of the same type, and sets the 6502<br />flags register like the CMP instruction.  TEMP07 points to the first field<br />(equivalent to the contents of the 6502 A register in the CMP instruction),<br />and TEMP06 points to the second field.  If the two fields being compared are<br />strings, then wildcards are allowed in the second string.<br /><br />On entry:       A               contains the field type: A, N, D or Y; must<br />                                be in upper case.<br />                TEMP07          points to field 1.<br />                TEMP06          points to field 2.<br /><br />On exit:        VS              error in one of the fields supplied: eg<br />                                illegal date; result not valid.<br />                C flag          set according to compare.<br />                Z flag          set according to compare.<br />                A,X,Y           undefined.<br /><br /><br />SCHFLD<br /><br />SCHFLD is used to find the number of a field, given its name.  It searches<br />the list of fields in the format file until it finds one that fits the name<br />given.  The name that you specify can obtain wild cards: the single wildcard<br />"?", and the multiple wildcard "*" are both allowed.  SCHFLD will always<br />return the first field in the format file that fits the name you have given.<br />You can either continue searching for more fields by using the SCHFLD call<br />described next.<br /><br />The name of the field is set up in the 16 byte LWORK area.  It should be<br />terminated by a null, or an end of field marker.  It must not be longer then<br />16 bytes, including the delimiter.<br /><br />On entry:       LWORK           contains name to search for; maximum of 16<br />                                bytes including delimiter; delimiter null<br />                                or end of field marker; wildcards "?" and<br />                                "*" valid.<br /><br />On exit:        CS              no field found to match the name; A has<br />                                error code.<br />                CC              field found OK; field number in X.<br /><br /><br />SCHFLN<br /><br />After calling SCHFLD, you can search for other fields which also fit the<br />field specification that you gave given, by making repeated calls to SCHFLN.<br />Before you call SCHFLN, you must have called SCHFLD first, to start the<br />sequence, and this call must have successfully found a field.<br /><br />You can keep calling SCHFLN until the call returns with the Carry flag set<br />to indicate that it has found no more fields.<br /><br />On entry:               Must have called SCHFLD first, and this must have<br />                        returned with the Carry flag clear.<br />           A            Contains field number to start searching<br />                        from.  This should be one more than the last value<br />                        that SCHFLD or SCHFLN returned in X.<br /><br />On exit:   CS           no more fields found; A has error code  (report only<br />                        if required).<br />           CC           field found; field number in X.<br /><br /><br />GETWID<br /><br />GETWID returns the display width of a field, as defined in the format file.<br />If there is no display width defined, a series of defaults comes into<br />action.<br /><br />Display width defined                   Display width <br />No display width, Sheet mode            18<br />No display width, Card mode             0<br /><br />On entry:               X               contains number of field for which<br />                                        width is required.<br /><br />On exit:                CS              field doesn't exit.<br />                        CC              field found; A has display width.<br />                        X               preserved.<br />                        Y               undefined.<br /><br /><br />GETKYW<br /><br />This routine finds the key width for a given field.  It uses the value<br />defined in the format file, if any; otherwise a system of defaults operates:<br /><br />Key width defined                               Key width <br />No key width, display width defined             Display width<br />No key width or display width                   10<br /><br />On entry:               X       contains number of field for which width is<br />                                required.<br /><br />On exit:                CS      field doesn't exist.<br />                        CC      field found; A has already width.<br />                        X       preserved.<br />                        Y       undefined.<br /><br /><br />GETKYW<br /><br />This routine finds the key width for a given field.  It uses the value<br />defined in the format file, if any; otherwise a system of defaults operates:<br /><br />Key width defined                               Key width<br />No key width, display width defined             Display width<br />No key width or display width                   10<br /><br />On entry:       X               contains the field number for which the key<br />                                width is required.<br /><br />On exit:        A               contains key width; if field doesn't exist,<br />                                a default key width of 10 is returned.<br />                X               preserved.<br />                Y               undefined.<br /><br /><br />CALSBN<br /><br />This routine is used when displaying numeric fields, to calculate the number<br />of spaces to be output before the number in order to right justify the<br />number within its field width.  This also takes into account the decimal<br />places specified in the format file.<br /><br />On entry:       X               contains the field number.<br />                TEMP07          points to the beginning of the field in<br />                                question.<br />                TEMP03          contains the field display width, as<br />                                returned by the GETWID routine.<br /><br />On exit:        A               gives number of spaces to output, zero if<br />                                the number is wider than the field, or there<br />                                are too many decimal places.<br />                X               undefined.<br />                Y               undefined.<br />                TEMP03          preserved.<br />                TEMP07          preserved.<br /><br /><br />File Control<br /><br />File handling in ViewStore is centred around three things: error handling,<br />FBLOCK and prefixes.  Since the error handling provided by the normal filing<br />system interface provided is completely unsatisfactory for a program such as<br />ViewStore, I have developed a system which gives control of what happens<br />after a disc or filing system error.  For the utility writer, this system is<br />transparent: you can forget about it as long as you use the calls provided,<br />and don't call the filing system directly.  If you do this, you can forget<br />all about BRK errors and handlers.<br /><br />The system is the same for all file calls: the state of the Overflow (V)<br />flag indicates after a call whether an error has occurred.  If there has<br />been an error, then the V flag is set, and the A register contains the error<br />code.  If you detect an error, you should unravel yourself from any<br />routines, report the error by calling the REPERL routine, and then close any<br />files that you have opened yourself, before returning to control of the ROM.<br />You shouldn't close the intermediate file: this is done automatically when<br />control is passed back to the ROM.<br /><br /><br />Filenames<br /><br />FBLOCK is a small of memory used to store and manipulate filenames.  Several<br />routines are provided which work on the filename in FBLOCK, altering<br />directories and prefixes.<br /><br />A filename in ViewStore is made up of three parts:<br /><br />        Prefix<br />        Directory<br />        Name<br />       <br />ViewStore maintains a list of the current prefixes for each different file<br />type: data; format; sort and so on.  A routine which adds a specified prefix<br />to a directory and name stored in FBLOCK is available.  The maximum length<br />of a prefix is 13 characters, excluding delimiter.  The current prefixes can<br />only be altered with the PREFIX command in ViewStore's Command Mode.<br /><br />ViewStore considers directories to be single character; of course the prefix<br />can include multiple character directories, but the filenames of data and<br />format files, for example, begin with directories, and these are always<br />single character directory names, whatever the filing system.  Directories<br />must be separated from the name itself by a dot, making the total size of<br />the directory section of a filename 2 characters.<br /><br />The name part of the filename can be up to 10 characters long.  This does<br />not include the directory and separator, or the delimiter.  Names are always<br />delimited with a Carriage Return character.<br /><br />Part            Max. Size (exc. delimiter)      Example<br /><br />Prefix          13                              :2.<br />Director        2                               d.<br />Name            10                              datafile<br /><br />MOVFBK          Moves a filename from the store area into FBLOCK.<br />MOVNAY          Moves a filename out of FBLOCK into the store area.<br />CHKDIR          Checks for the presence of a directory in a filename in<br />                FBLOCK, and returns the directory character, if there is<br />                one.<br />SETDIR          Sets a directory into a filename in FBLOCK.<br />STXPRE          Stores the required prefix with a filename in FBLOCK.<br />OPFILE          Gives access to the filing system OSFIND call.<br />OSHCAL          Gives access to the filing system OSFILE call.<br />XOSARG          Vector with error trapping to OSARGS.<br />XOSBGE          Vector with error trapping to OSBGET.<br />XOSBPU          Vector with error trapping to OSBPUT.<br />XOSCLS          Vector  with error trapping to OSFIND with A=0; used to<br />                close a file.<br />XOSGBP          Vector with error trapping to OSGBPB.<br />CALUTI          Loads and runs a utility format file.<br /><br /><br />MOVFBK<br /><br />MOVFBK moves a filename from ViewStore's list into FBLOCK.  A summary of the<br />filenames available and their offsets is given in table 8.  Filenames are<br />not stored with prefixes attached, but they do include the directory.  You<br />must use the routine STXPRE to add a prefix to the filename once it has been<br />moved to FBLOCK, before calling one of the file routines.<br /><br />On entry:       Y       contains the offset of the filename to be<br />                        moved into FBLOCK.<br /><br />On exit:        A,X,Y   undefined.<br /><br /><br />MOVNAY<br /><br />This routine is the inverse of MOVFBK; it moves a filename from FBLOCK into<br />ViewStore's list of names.  The filename in FBLOCK should not include the<br />prefix when this routine is called.  The list of filename offset values is<br />given in table 8.<br /><br /><br />On entry:       X               contains the offset of the filename area in<br />                                which the name currently in FBLOCK is to be<br />                                stored.<br /><br />On exit:        A,X,Y           undefined.<br /><br /><br />CHKDIR<br /><br />CHKDIR checks whether the filename in FBLOCK has a directory, and if it<br />does, it returns the directory.  The filename should not include the prefix<br />when this routine is called.<br /><br />On entry:                               filename to check in FBLOCK.<br /><br />On exit:                CS              filename contains directory;<br />                                        directory character  found returned<br />                                        in A; offset from beginning of<br />                                        FBLOCK to the directory character is<br />                                        in X.<br />                        CC              no directory found.<br />                        Y               undefined.<br /><br /><br />SETDIR<br /><br />SETDIR forces a directory into the filename in FBLOCK.  It doesn't matter<br />whether the filename there contains a directory or not; SETDIR will make<br />space for it.  The filename must not include a prefix when SETDIR is called.<br /><br />On entry:       A               contains directory character to set into name<br />                                in FBLOCK.<br /><br />On exit:        A,X,Y           undefined.<br /><br /><br />STXPRE<br /><br />This is the routine that you use to add a prefix to a name.  The name<br />itself, including directory, should be in FBLOCK.  Normally, adding the<br />prefix to a name is the last thing you do before calling the filing system<br />to do some operation on the file: opening or deleting the file, for example.<br />Names themselves should be stored without prefix attached, the prefix being<br />added only when calling the filing system itself.<br /><br />A list of the prefix offsets for different file types is given in table 7.<br /><br />On entry:       X               contains the offset of the prefix required.<br /><br />On exit:        A,X,Y           undefined.<br /><br /><br />OPFILE<br /><br />OPFILE is an equivalent of the filing system "OSFIND" call, used for opening<br />files.  It assumes, however, that the filename is ready in FBLOCK.  OPFILE<br />cannot be used to close a file, as OSFIND can; use the XOSCLS call to close<br />a file.  OPFILE also uses the ViewStore error trapping system.       <br /><br />On entry:       A               contains file open code, as for OSFIND; eg.<br />                                &40 is open for input.<br /><br />On exit:        VS              error occurred; error code in A.<br />                VC              no error occurred; file handle is in both A<br />                                and Y registers; usual OSFIND error of file<br />                                handle being zero when the file can't be<br />                                found is trapped:  V is set, and the<br />                                ViewStore "File not found" error code is in<br />                                A; Y is zero.<br />                X               undefined.<br /><br /><br />OSHCAL<br /><br />OSHCAL gives the utility access to the filing system OSFILE routine.  It<br />uses the OSFARA area as its control block.  Note that this spills over into<br />the LWORK area, which will be corrupted after an OSHCAL call.  OSHCAL<br />assumes that the filename (when required) is set up in FBLOCK.  OSHCAL also<br />sets the high order addresses into the control block at OSFARA +4 and +5;<br />+&C and +&D; and at +&10 and +&11.  ViewStore error trapping is also<br />enabled.<br /><br />On entry:       A               contains reason code as for normal OSFILE<br />                                (see filing system manual).<br />                OSFARA          set up with whatever the reason code action<br />                                requires, eg. start and end addresses for<br />                                file save.<br /><br />On exit:        VS              error occurred; error code in A.<br />                VC              completed successfully; file type in A when<br />                                relevant.<br />                X,Y             undefined.<br /><br /><br />XOSARG<br /><br />XOSARG is equivalent to OSARGS, except that ViewStore error handling is<br />enabled.<br /><br />On entry:                       See filing system manual for OSARGS.<br /><br />On exit:        VS              error occurred; error code in A.<br />                VC              no error; see filing system manual for<br />                                results.<br /><br /><br />PART 2 IN THE NEXT 8BS ISSUE<br /><br />    </td></tr></table>
  </body>
</html>